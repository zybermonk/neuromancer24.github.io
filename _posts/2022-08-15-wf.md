---
layout: distill
title: The magical window function
date: 2022-08-15
tags: data
description: Some data analytics with Postgres

authors:
  - name: Mohan Ramesh
    url: "https://github.com/Neuromancer24"
    affiliations: 
      name: None

toc:
  - name: The window function
    subsections:
        - name: 1. Loading the Data
        - name: 2. Aggregations
        - name: 3. Row-sequencing part 1
        - name: 4. Row-sequencing part 2
        - name: 5. Inter-row calculations
        - name: 6. Bonus!
  - name: Conclusion

_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }

---

 

# The window function

Are you looking to do some data analytics with Postgres, and want to explore some interesting techniques? You are in the right place. There’s a huge list of features that Postgres is offering, and Window functions are a part of this overall offering, basically they are a part of these vast analytical toolsets that Postgres offer. 

**What are these window functions actually?**

A [window function](https://www.gooddata.com/blog/sql-21st-century-analytic-window-functions/)/ an analytical function performs a calculation across a set of table rows that aresomehow related to the current row. That’s kind of obvious and similar to what aggregate functions do, right? Yes and No. There’s a fundamental difference between window functions and other functions, i.e., window functions do not cause rows to become grouped into a single output row like non-window aggregate functions would.

**Interesting, but how are they useful?**

Let us look at a small case study to better understand the window functions and their magic! In this article we use a table called ‘topups’ from a database of a small mobile company. We have a flat file in a TSV format. Let us go ahead and import this data.

## 1. Loading the Data

Instead of copying and morphing the data, we keep the integrity of the source data by accessing the data using a foreign table, which is one of the many ways to access remote data. To do this we make use of an extension called file_fdw, which is a module that provides foreign data wrapper tool.

<div>
{% include figure.html path="assets/img/posts/wf1.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

Once the extension is installed we can easily create a table by accessing the data from the remote server we just created. However, we need to make sure the column are defined exactly as in the source database. The syntax looks something as below.

<div>
{% include figure.html path="assets/img/posts/wf2.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

Now, we can either copy this to a new table or directly access data from this foreign table.


## 2. Aggregations

The data we are about to access looks something like this,
<div>
{% include figure.html path="assets/img/posts/wf3.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

There are different types of window functions, and can be grouped into the following,

- Aggregate Window Functions
    SUM (), MAX (), MIN (), AVG (), COUNT ()
- Ranking Window Functions
    RANK (), DENSE_RANK (), ROW_NUMBER (), NTILE ()
- Value Window Functions
    LAG (), LEAD (), FIRST_VALUE (), LAST_VALUE ()

We take a look at some of the window functions and their examples using our foreign table, ‘topups’

`Listing the total of ALL topups done by a user, if they have ever had a top up of exactly € 15
`
The first thought in our mind would be to use a select query to get all the users (id_user) who have had a top up of € 15 and any top ups other than €15. This requires a nested select query and a join operation. But can also be done using a single select statement, however, this only works if and only if we know that all the users have at least once done a €15 top up.

<div>
{% include figure.html path="assets/img/posts/wf4.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
The previous code results in an output as below
<div>
{% include figure.html path="assets/img/posts/wf5.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
In the above example we have assumed that all users have made a top up of €15 at least once, but what if we did not have this information?

So, what do we do now? We go for aggregate functions! (Traditionally)
<div>
{% include figure.html path="assets/img/posts/wf6.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
Output will be like below
<div>
{% include figure.html path="assets/img/posts/wf5.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
We can clearly see that simple aggregate function can solve this problem. But why do we need the window function? Just look at the code above, its long, confusing for other people and its messy. Hence, we will try to solve the same problem by using the window function and see for ourselves, the magic of window functions!

**Take a look at this snippet of code below**
<div>
{% include figure.html path="assets/img/posts/wf7.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

WOW! What happened here. The query length is reduced to less than half and this also keeps the identity of each row, allowing us an access to the gateway for plenty of analysis which previously was hindered due to the usage of mere aggregate functions.
<div>
{% include figure.html path="assets/img/posts/wf8.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
For example, the date column has still maintained its integrity when we use a window function, which is a huge advantage while doing several data analytics tasks which we will see further in this article.

SQL window functions, as demonstrated in this article, are a powerful notion that enables for sophisticated computations. A typical window function consists of an expression and a window specification, with optional partitioning and a frame clause, and the possibilities for slicing, smoothing, interconnecting, and deduplicate data are virtually limitless. There are plenty of interesting use cases where these functions give a great value. We’ll continue talking about them in the next few sections. Stay tuned!


## 3. Row-sequencing part 1

`Displaying latest top 5 top ups for each user`

The first thought now would be... definitely a lot of subqueries and join operations. Very tedious! But
also, using the general aggregate functions would combine the rows and output a single row. If we
recall the introduction section of this article, we can say this is where the magic of window functions
happens. We make use of Ranking window functions to solve this problem and still display individual
rows for each operation.

**Consider the code snippet below**
<div>
{% include figure.html path="assets/img/posts/wf9.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
The output will be something like this
<div>
{% include figure.html path="assets/img/posts/wf.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
Same date but ranked in decreasing order of top up value


We successfully completed the task 3 by using a combination of a few window functions, which are
easy to read, understand and debug!

## 4. Row sequencing part 2

`Displaying Top 5 largest topups by each user, while retaining the immediately following topups if the
subsequent values are same`

**Consider the code snippet below**
<div>
{% include figure.html path="assets/img/posts/wf10.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
The output will be as follows
<div>
{% include figure.html path="assets/img/posts/wf11.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

Just by altering a few lines, we now have solved task too. That is the power of window functions!

## 5. Inter-row calculations

`Creating a new table using the original table by adding additional columns`

We can easily create a new table from an existing dataset whilst creating new columns using the operations performed on the older tables’ columns. Window functions, as opposed to aggregation, return a result for each row. You can use window functions in a Custom Formula transformation of a Data Prep recipe.

**Consider the code snippet below**
<div>
{% include figure.html path="assets/img/posts/wf12.jpeg" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
The new table created looks like below

<div>
{% include figure.html path="assets/img/posts/wf13.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

## 6. Bonus!

Now to the final task! We use all the knowledge gained till now and use it all to solve a single problem.
Let us consider a Promotion scheme run by our mobile company. The gift is a free credit for 28 days if a user tops up by €20 or more. Promotion will be applied the same day of the top up immediately. So, we need to find the users who are eligible for the promotion and their promotion period. Promotion can be availed multiple time too!
<div>
{% include figure.html path="assets/img/posts/wf14.jpeg" title="example image" class="img-fluid rounded z-depth-1" %}
</div>
So, what will be our approach to solve this? A good approach will be to filter out topups which are €20 or more for each user and compute the difference between their subsequent latest topups. Then setting flags for start and end period will further help us to filter only those which fall in the 28 - day period (for every start period +28 is added to get end period). Then we can sort individual users who are eligible, and we have our desired output!

The output will be as follows

<div>
{% include figure.html path="assets/img/posts/wf15.png" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

# Conclusion

<div>
{% include figure.html path="assets/img/posts/wfm.jpeg" title="example image" class="img-fluid rounded z-depth-1" %}
</div>

Basically, window functions are very powerful!

```
Source: https://www.toptal.com/sql/intro-to-sql-windows-functions
```
While this is a brief overview of PostgreSQL window functions, perhaps it has piqued our curiosity in learning more about what they can accomplish. We discovered that window functions execute calculations in the same way as aggregation functions do, but with the extra bonus of having access to data within individual rows, making them extremely powerful. Also, the window functions only need one sequential scan of the table and regular joins need 2 sequential scans of the table values.

They always contain the OVER clause, and may contain PARTITION BY, ORDER BY, and a host of aggregating (SUM, COUNT, etc.) and other positional functions (LEAD, LAG). We also learned about window frames and how they encapsulate sections of data.